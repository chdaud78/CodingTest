// 등굣길

/**
 * ✏️ 문제
 * - m×n 격자에서 (1,1)→(m,n)로 오른쪽/아래만 이동하며
 *   물웅덩이([x,y], 1-based, x=열·y=행)를 피한 경로 수의 1,000,000,007 나머지를 구하기.
 *
 * ✏️ 목표
 * - 시간 O(m·n), 공간 O(m)인 동적 계획법(DP)으로 경로 수를 계산한다.
 * - 큰 수를 처리하기 위해 모든 덧셈은 MOD(1e9+7)로 나눈다.
 *
 * ✏️ 해결 전략
 * 1. 물 칸을 빠르게 판별하기 위해 문자열 키(`${x},${y}`)를 원소로 갖는 Set을 만든다.
 * 2. 1차원 DP 배열 dp[x]를 사용하여, 현재 행 y를 처리할 때 (x,y)까지 도달하는 경로 수
 * 3. 시작 칸(1,1)은 1로 시작하되, 루프에서 물 칸이면 0으로 바로 덮어쓴다.
 * 4. 각 갱신 시 MOD로 나머지 연산을 적용해 오버플로를 방지한다.
 */

function solution(m, n, puddles) {
  const MOD = 1_000_000_007;
  const key = (x, y) => `${x},${y}`;

  // 물 칸 집합 (puddles는 [[x,y], ...]; x는 열, y는 행)
  const water = new Set(puddles.map(([x, y]) => key(x, y)));

  // dp[x] = 현재 행 y에서 (x,y)까지 올 수 있는 경로 수
  const dp = Array(m + 1).fill(0);
  dp[1] = 1; // (1,1) 시작값 — 만약 물이면 아래 루프에서 0으로 덮인다.

  for (let y = 1; y <= n; y++) {
    for (let x = 1; x <= m; x++) {
      if (water.has(key(x, y))) {
        dp[x] = 0; // 물 칸은 진입 불가
        continue;
      }
      if (x === 1 && y === 1) {
        dp[x] = 1; // 시작 칸 재확인 (가독성용)
        continue;
      }
      const left = x > 1 ? dp[x - 1] : 0; // 왼쪽에서 오는 경로 수
      dp[x] = (dp[x] + left) % MOD; // 위(dp[x]) + 왼쪽(dp[x-1])
    }
  }
  return dp[m];
}

/**
 * 📖 풀이 과정 정리
 *
 * 1️⃣ 입력 해석
 * - 격자는 1-based 좌표이며, puddles는 [x,y]로 주어진다.
 * - 물 칸은 이동 불가다(해당 칸의 경로 수는 항상 0).
 *
 * 2️⃣ 자료구조 선택
 * - 물 칸 조회를 O(1)로 만들기 위해 Set을 사용하고,
 *   좌표는 `${x},${y}` 문자열 키로 변환한다.
 *
 * 3️⃣ 상태 정의(1차원 DP)
 * - dp[x]를 “현재 처리 중인 행 y에서 (x,y)에 도달하는 경로 수”로 정의한다.
 * - 위에서 내려오는 경우(dp[x])와 왼쪽에서 오는 경우(dp[x-1])만 존재한다.
 *
 * 4️⃣ 점화식과 초기값
 * - 점화식: blocked(x,y) ? 0 : (dp[x] + dp[x-1]) (단, x>1일 때만 dp[x-1] 사용)
 * - (1,1)은 1로 시작. 만약 (1,1)이 물이면 루프에서 0으로 덮여 최종 답 0이 된다.
 */
