// 정수 삼각형

/**
 * ✏️ 문제
 * - 바닥까지 내려가는 경로 중 숫자의 합이 가장 큰 값을 구하라.
 *
 * ✏️ 목표
 * - 가능한 모든 경로 중에서 최대 합을 찾아 반환.
 * - 효율적으로 풀기 위해 O(n²) 시간 안에 해결.
 *
 * ✏️ 해결 전략
 * 1. 아래 행에서부터 위로 올라가면서 각 위치에서 만들 수 있는 최대 합을 누적.
 * 2. dp[j] = 현재 위치 값 + max(아래 행에서 j, j+1 위치 값)
 * 3. 최종적으로 dp[0]이 전체 경로의 최대 합이 됨.
 * 4. 추가 메모리 없이 triangle의 마지막 행을 그대로 dp 버퍼로 재사용.
 */

// ✅ 풀이 코드
function solution(triangle) {
  const len = triangle.length;
  if (len === 0) return 0;

  // 마지막 행을 dp 버퍼로 사용 (in-place)
  const dp = triangle[len - 1];

  // 아래에서 위로 누적 계산
  for (let i = len - 2; i >= 0; i--) {
    const row = triangle[i];

    for (let j = 0; j <= i; j++) {
      const a = dp[j]; // 아래 행 같은 열 값
      const b = dp[j + 1]; // 아래 행 오른쪽 열 값
      dp[j] = row[j] + (a > b ? a : b); // 현재 값 + 더 큰 하위 경로
    }
  }
  return dp[0];
}

/**
 * 📖 풀이 과정 정리
 *
 * 1️⃣ dp 초기화
 * - 삼각형 마지막 행을 dp로 두어, 해당 위치에서의 "현재까지 최대 합" 저장.
 *
 * 2️⃣ 역순 반복
 * - 두 번째 마지막 행부터 위로 올라가면서 각 칸을 갱신.
 *
 * 3️⃣ 값 갱신
 * - dp[j] = triangle[i][j] + max(dp[j], dp[j+1])
 * - 아래 행의 같은 열과 오른쪽 열 중 큰 값을 더함.
 *
 * 4️⃣ 공간 최적화
 * - dp 배열을 매번 새로 만들지 않고 마지막 행을 그대로 재사용.
 * - 공간 복잡도 O(1).
 *
 * 5️⃣ 결과 반환
 * - dp[0]이 꼭대기에서 시작하는 최대 경로 합.
 */
